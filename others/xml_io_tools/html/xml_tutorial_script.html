
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>Tutorial for xml_io_tools Package</title>
      <meta name="generator" content="MATLAB 7.6">
      <meta name="date" content="2008-09-10">
      <meta name="m-file" content="xml_tutorial_script"><style>

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head>
   <body>
      <div class="content">
         <h1>Tutorial for xml_io_tools Package</h1>
         <introduction>
            <p><b>By Jarek Tuszynski</b></p>
            <p>Package xml_io_tools can read XML files into MATLAB struct and writes MATLAB data types to XML files with help of simple interface
               to MATLAB's xmlwrite and xmlread functions.
            </p>
            <p>Two function to simplify reading and writing XML files from MATLAB:</p>
            <div>
               <ul>
                  <li>Function xml_read first calls MATLAB's xmlread function and than converts its output ('Document Object Model' tree of Java
                     objects) to tree of MATLAB struct's. The output is in the format of nested structs and cells. In the output data structure
                     field names are based on XML tags.
                  </li>
               </ul>
            </div>
            <div>
               <ul>
                  <li>Function xml_write first convert input tree of MATLAB structs and cells and other types to tree of 'Document Object Model'
                     nodes, and then writes resulting object to XML file using MATLAB's xmlwrite function. .
                  </li>
               </ul>
            </div>
         </introduction>
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#1">This package can:</a></li>
               <li><a href="#2">This package does not:</a></li>
               <li><a href="#3">Change History</a></li>
               <li><a href="#4">Licence</a></li>
               <li><a href="#5">Write XML file based on a Struct using "xml_write"</a></li>
               <li><a href="#6">Read XML file producing a Struct using "xml_read"</a></li>
               <li><a href="#7">"Pref.XmlEngine" flag in "xml_write"</a></li>
               <li><a href="#8">Writing Struct with MATLAB arrays</a></li>
               <li><a href="#9">Read Struct with MATLAB arrays</a></li>
               <li><a href="#10">"Pref.StructItem" flag in "xml_write"</a></li>
               <li><a href="#16">"Pref.CellItem" flag in "xml_write"</a></li>
               <li><a href="#20">"Pref.NoCells" flag in "xml_read"</a></li>
               <li><a href="#24">"Pref.ItemName" flag in "xml_write"</a></li>
               <li><a href="#26">"Pref.ItemName" flag in "xml_read"</a></li>
               <li><a href="#28">"Pref.Str2Num" flag in xml_read</a></li>
               <li><a href="#35">Write XML files with ATTRIBUTEs</a></li>
               <li><a href="#37">Write XML files with COMMENTs</a></li>
               <li><a href="#43">Write XML files with PROCESSING_INSTRUCTIONs</a></li>
               <li><a href="#49">Write XML files with CDATA Sections</a></li>
               <li><a href="#51">Write XML files with special characters in TAG names</a></li>
               <li><a href="#55">Write XML files with Namespaces</a></li>
               <li><a href="#57">"Pref.KeepNS" flag in "xml_read"</a></li>
               <li><a href="#59">Read XML files with special node types</a></li>
               <li><a href="#62">"Pref.ReadAttr" flag in "xml_read"</a></li>
               <li><a href="#63">"Pref.ReadSpec" flag in "xml_read"</a></li>
               <li><a href="#64">"Pref.RootOnly" flag in "xml_read"</a></li>
               <li><a href="#65">"Pref.RootOnly" flag in "xml_write"</a></li>
               <li><a href="#67">"Pref.NumLevels" flag in "xml_read"</a></li>
               <li><a href="#70">Create DOM object based on a Struct using "xml_write"</a></li>
               <li><a href="#72">Convert DOM object to Struct using "xml_read"</a></li>
               <li><a href="#73">Write XML file based on a DOM using "xml_write_xerces"</a></li>
               <li><a href="#74">Write XML to string instead of a file</a></li>
            </ul>
         </div>
         <h2>This package can:<a name="1"></a></h2>
         <div>
            <ul>
               <li>Read most XML files, created inside and outside of MATLAB, and   convert them to MATLAB data structures.</li>
               <li>Write any MATLAB's struct tree to XML file</li>
               <li>Handle XML attributes in the same way as xml_toolbox package</li>
               <li>Handle special XML nodes like comments, processing instructions and   CDATA sections</li>
               <li>Be studied, modified, customized, rewritten and used in other packages   without any limitations. All code is included and
                  documented. Software   is distributed under MIT Licence (included).
               </li>
            </ul>
         </div>
         <h2>This package does not:<a name="2"></a></h2>
         <div>
            <ul>
               <li>Guarantee to recover the same Matlab objects that were saved. If you need to be able to recover carbon copy of the structure
                  that was saved than you will have to use one of the packages that uses special set of tags saved as xml attributes that help
                  to guide the parsing of XML code. This package does not do that.
               </li>
               <li>Guarantee to work with older versions of MATLAB. Functions do not work with versions of MATLAB prior to 7.1 (26-Jul-2005).
                  Versions starting with 7.1 seem to work on my machine, which have current java engine and libraries.
               </li>
            </ul>
         </div>
         <h2>Change History<a name="3"></a></h2>
         <div>
            <ul>
               <li>2006-11-06 - original version</li>
               <li>2006-11-26 - corrected xml_write to handle writing Matlab's column   arrays to xml files. Bug discovered and diagnosed by
                  Kalyan Dutta.
               </li>
               <li>2006-11-28 - made changes to handle special node types like:   COMMENTS and CDATA sections</li>
               <li>2007-02-20 - Writing CDATA sections still did not worked. The problem   was diagnosed and fixed by Alberto Amaro. The fix
                  involved rewriting   xmlwrite to use Apache Xerces java files directly instead of MATLAB's   XMLUtils java class.
               </li>
               <li>2007-06-20 - Fixed problem reported by Anna Kelbert in Reviews about   not writing attributes of ROOT node. Also: added support
                  for Processing   Instructions, added support for global text nodes: Processing   Instructions and comments, allowed writing
                  tag names with special   characters
               </li>
               <li>2007-07-19 - Added tutorial script file. Extended support for global   text nodes. Added more Preference fields.</li>
               <li>2008-01-05 - Fixed problem reported by Anna Krewet of converting dates   in format '2007-01-01' to numbers. Improved and added
                  warning messages.   Added detection of old Matlab versions incompatible with the library.   Expanded documentation.
               </li>
               <li>2008-06-14 - Fixed problem with writing 1D array reported by Mark Neil.   Extended xml_read's Pref.Num2Str to 3 settings (never,
                  smart and always)   for better control. Added parameter Pref.KeepNS for keeping or ignoring   namespace data when reading.
                  Fixed a bug related to writing 2D cell   arrays brought up by Andrej's Mosat review.
               </li>
            </ul>
         </div>
         <h2>Licence<a name="4"></a></h2>
         <p>The package is distributed under MIT Licence</p><pre class="codeinput">format <span class="string">compact</span>; <span class="comment">% viewing preference</span>
clear <span class="string">variables</span>;
type(<span class="string">'MIT_Licence.txt'</span>)
</pre><pre class="codeoutput">
Copyright (c) 2007 Jarek Tuszynski

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
</pre><h2>Write XML file based on a Struct using "xml_write"<a name="5"></a></h2>
         <p>Any MATLAB data struct can be saved to XML file. Notice that 'tree' only defines content of the root element. Its name has
            to be either passed separately or deduced from the input variable name.
         </p><pre class="codeinput">MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString = <span class="string">'Hello World'</span>;
xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><h2>Read XML file producing a Struct using "xml_read"<a name="6"></a></h2><pre class="codeinput">[tree treeName] = xml_read (<span class="string">'test.xml'</span>);
disp([treeName{1} <span class="string">' ='</span>])
gen_object_display(tree)
</pre><pre class="codeoutput">MyTree =
    MyNumber: [13]
    MyString: 'Hello World'
</pre><h2>"Pref.XmlEngine" flag in "xml_write"<a name="7"></a></h2>
         <p>Same operation using Apache Xerces XML engine. Notice that in this case root element name was passed as variable and not extracted
            from the variable name.
         </p><pre class="codeinput">Pref=[]; Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'TreeOfMine'</span>, Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;TreeOfMine&gt;
    &lt;MyNumber&gt;13&lt;/MyNumber&gt;
    &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/TreeOfMine&gt;

</pre><h2>Writing Struct with MATLAB arrays<a name="8"></a></h2><pre class="codeinput">MyTree=[];
MyTree.Num_1x1 = 13;
MyTree.Vec_1x3 = [1 2 3];
MyTree.Vec_4x1 = [1; 2; 3; 4];
MyTree.Mat_2x2 = [1, 2; 3, 4];         <span class="comment">% 2D Matrix</span>
MyTree.Cube_3D = reshape(1:8,[2 2 2]); <span class="comment">% 3D array</span>
MyTree.String1 = <span class="string">'[2003 10 30]'</span>;       <span class="comment">% array with    [] brackets</span>
MyTree.String2 =  <span class="string">'2003 10 30'</span>;        <span class="comment">% array without [] brackets</span>
xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;Num_1x1&gt;13&lt;/Num_1x1&gt;
   &lt;Vec_1x3&gt;[1 2 3]&lt;/Vec_1x3&gt;
   &lt;Vec_4x1&gt;[1; 2; 3; 4]&lt;/Vec_4x1&gt;
   &lt;Mat_2x2&gt;[1 2; 3 4]&lt;/Mat_2x2&gt;
   &lt;Cube_3D&gt;1 2 3 4 5 6 7 8&lt;/Cube_3D&gt;
   &lt;String1&gt;[2003 10 30]&lt;/String1&gt;
   &lt;String2&gt;2003 10 30&lt;/String2&gt;
&lt;/MyTree&gt;
</pre><h2>Read Struct with MATLAB arrays<a name="9"></a></h2>
         <p>Notice that by default 'String2' was not converted to a array - see section on Str2Num for details. Also notice that 'Cube_3D'
            did not preserve original dimentions
         </p><pre class="codeinput">[tree treeName] = xml_read (<span class="string">'test.xml'</span>);
disp([treeName{1} <span class="string">' ='</span>])
gen_object_display(tree)
</pre><pre class="codeoutput">MyTree =
    Num_1x1: [13]
    Vec_1x3: [1  2  3]
    Vec_4x1: [4x1 double]
    Mat_2x2: [2x2 double]
    Cube_3D: [1  2  3  4  5  6  7  8]
    String1: [2003    10    30]
    String2: [2003    10    30]
</pre><h2>"Pref.StructItem" flag in "xml_write"<a name="10"></a></h2>
         <p><b>Create a simple structure with arrays of struct's</b></p><pre class="codeinput">MyTree = [];
MyTree.a(1).b = <span class="string">'jack'</span>;
MyTree.a(2).b = <span class="string">'john'</span>;
gen_object_display(MyTree)
</pre><pre class="codeoutput">    a: [1x2 struct]
       b: 'jack'

       b: 'john'

</pre><p><b>Write XML with "StructItem = true" (default).  Notice single 'a' section and multiple 'item' sub-sections. Those subsections
               are used to store array elements</b></p><pre class="codeinput">wPref.StructItem = true;
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>,wPref);
type(<span class="string">'test.xml'</span>)
fprintf(<span class="string">'\nxml_read output:\n'</span>)
gen_object_display(xml_read (<span class="string">'test.xml'</span>))
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;a&gt;
      &lt;item&gt;
         &lt;b&gt;jack&lt;/b&gt;
      &lt;/item&gt;
      &lt;item&gt;
         &lt;b&gt;john&lt;/b&gt;
      &lt;/item&gt;
   &lt;/a&gt;
&lt;/MyTree&gt;

xml_read output:
    a: [1x2 struct]
       b: 'jack'

       b: 'john'

</pre><p><b>Write XML with "StructItem = false". Notice multiple 'a' sections</b></p><pre class="codeinput">wPref.StructItem = false;
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>,wPref);
type(<span class="string">'test.xml'</span>)
fprintf(<span class="string">'\nxml_read output:\n'</span>)
gen_object_display(xml_read (<span class="string">'test.xml'</span>))
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;a&gt;
      &lt;b&gt;jack&lt;/b&gt;
   &lt;/a&gt;
   &lt;a&gt;
      &lt;b&gt;john&lt;/b&gt;
   &lt;/a&gt;
&lt;/MyTree&gt;

xml_read output:
    a: [1x2 struct]
       b: 'jack'

       b: 'john'

</pre><p><b>Notice that xml_read function produced the same struct when reading both files</b></p>
         <p><b>Potential problems with "StructItem = true":</b></p><pre class="codeinput">wPref.StructItem = true;
MyTree1 = []; MyTree1.a.b    = <span class="string">'jack'</span>;
MyTree2 = []; MyTree2.a(1).b = <span class="string">'jack'</span>;
MyTree3 = []; MyTree3.a(2).b = <span class="string">'jack'</span>;
xml_write(<span class="string">'test.xml'</span>, MyTree1, [], wPref); type(<span class="string">'test.xml'</span>);
xml_write(<span class="string">'test.xml'</span>, MyTree2, [], wPref); type(<span class="string">'test.xml'</span>);
xml_write(<span class="string">'test.xml'</span>, MyTree3, [], wPref); type(<span class="string">'test.xml'</span>);
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree1&gt;
   &lt;a&gt;
      &lt;b&gt;jack&lt;/b&gt;
   &lt;/a&gt;
&lt;/MyTree1&gt;

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree2&gt;
   &lt;a&gt;
      &lt;b&gt;jack&lt;/b&gt;
   &lt;/a&gt;
&lt;/MyTree2&gt;

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree3&gt;
   &lt;a&gt;
      &lt;item&gt;
         &lt;b/&gt;
      &lt;/item&gt;
      &lt;item&gt;
         &lt;b&gt;jack&lt;/b&gt;
      &lt;/item&gt;
   &lt;/a&gt;
&lt;/MyTree3&gt;
</pre><p><b>Notice that MyTree1 and MyTree2 produce identical files with no 'items', while MyTree2 and MyTree3 produce very different
               file structures. It was pointed out to me that files produced from MyTree2 and MyTree3 can not belong to the same schema,
               which can be a problem.</b></p>
         <h2>"Pref.CellItem" flag in "xml_write"<a name="16"></a></h2>
         <p><b>Create a simple structure with cell arrays</b></p><pre class="codeinput">MyTree = [];
MyTree.a = {<span class="string">'jack'</span>, <span class="string">'john'</span>};
disp(MyTree)
</pre><pre class="codeoutput">    a: {'jack'  'john'}
</pre><p><b>Write XML with "StructItem = true" (default).  Notice single 'a' section and multiple 'item' sections</b></p><pre class="codeinput">Pref=[]; Pref.CellItem = true;
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>,Pref);
type(<span class="string">'test.xml'</span>)
fprintf(<span class="string">'\nxml_read output:\n'</span>);
disp(xml_read (<span class="string">'test.xml'</span>))
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;a&gt;
      &lt;item&gt;jack&lt;/item&gt;
      &lt;item&gt;john&lt;/item&gt;
   &lt;/a&gt;
&lt;/MyTree&gt;

xml_read output:
    a: {'jack'  'john'}
</pre><p><b>Write XML with "StructItem = false". Notice multiple 'a' sections</b></p><pre class="codeinput">Pref=[]; Pref.CellItem = false;
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>,Pref);
type(<span class="string">'test.xml'</span>)
fprintf(<span class="string">'\nxml_read output:\n'</span>);
disp(xml_read (<span class="string">'test.xml'</span>))
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;a&gt;jack&lt;/a&gt;
   &lt;a&gt;john&lt;/a&gt;
&lt;/MyTree&gt;

xml_read output:
    a: {'jack'  'john'}
</pre><p><b>Notice that xml_read function produced the same struct when reading both files</b></p>
         <h2>"Pref.NoCells" flag in "xml_read"<a name="20"></a></h2>
         <p><b>Create a cell/struct mixture object</b></p><pre class="codeinput">MyTree = [];
MyTree.a{1}.b = <span class="string">'jack'</span>;
MyTree.a{2}.b = [];
MyTree.a{2}.c = <span class="string">'john'</span>;
gen_object_display(MyTree);
</pre><pre class="codeoutput">    a: [1x2 cell] = 
       b: 'jack'

       b: [0x0 double]
       c: 'john'

</pre><p><b>Save it to xml file</b></p><pre class="codeinput">Pref=[]; Pref.CellItem = false;
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>,Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;a&gt;
      &lt;b&gt;jack&lt;/b&gt;
   &lt;/a&gt;
   &lt;a&gt;
      &lt;b/&gt;
      &lt;c&gt;john&lt;/c&gt;
   &lt;/a&gt;
&lt;/MyTree&gt;
</pre><p><b>Read above file with "Pref.NoCells=true" (default) - output is quite different then input</b> By default program is trying to convert everything to struct's and arrays of structs. In case arrays of structs all the structs
            in array need to have the same fields, and if they are not than MATLAB creates empty fields.
         </p><pre class="codeinput">Pref=[]; Pref.NoCells=true;
gen_object_display(xml_read(<span class="string">'test.xml'</span>, Pref))
</pre><pre class="codeoutput">    a: [2x1 struct]
       b: 'jack'
       c: [0x0 double]

       b: [0x0 double]
       c: 'john'

</pre><p><b>Read above file with "Pref.NoCells=false" - now input and output are the same</b> Cell arrays of structs allow structs in array to have different fields.
         </p><pre class="codeinput">Pref=[]; Pref.NoCells=false;
gen_object_display(xml_read(<span class="string">'test.xml'</span>, Pref))
</pre><pre class="codeoutput">    a: [1x2 cell] = 
       b: 'jack'

       b: [0x0 double]
       c: 'john'

</pre><h2>"Pref.ItemName" flag in "xml_write"<a name="24"></a></h2>
         <p><b>Create a cell/struct mixture object</b></p><pre class="codeinput">MyTree = [];
MyTree.a{1}.b = <span class="string">'jack'</span>;
MyTree.a{2}.c = <span class="string">'john'</span>;
gen_object_display(MyTree);
</pre><pre class="codeoutput">    a: [1x2 cell] = 
       b: 'jack'

       c: 'john'

</pre><p><b>Save it to xml file, using 'item' notation but with different name</b></p><pre class="codeinput">Pref=[];
Pref.CellItem = true;
Pref.ItemName = <span class="string">'MyItem'</span>;
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>,Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;a&gt;
      &lt;MyItem&gt;
         &lt;b&gt;jack&lt;/b&gt;
      &lt;/MyItem&gt;
      &lt;MyItem&gt;
         &lt;c&gt;john&lt;/c&gt;
      &lt;/MyItem&gt;
   &lt;/a&gt;
&lt;/MyTree&gt;
</pre><h2>"Pref.ItemName" flag in "xml_read"<a name="26"></a></h2>
         <p><b>Read above file with default settings ("Pref.ItemName = 'item'")</b> The results do not match the original structure
         </p><pre class="codeinput">Pref=[]; Pref.NoCells  = false;
gen_object_display(xml_read(<span class="string">'test.xml'</span>, Pref))
</pre><pre class="codeoutput">    a: [1x1 struct]
       MyItem: [1x2 cell] = 
               b: 'jack'

               c: 'john'

</pre><p><b>Read above file with "Pref.ItemName = 'MyItem'" - now saved and read MATLAB structures are the same</b></p><pre class="codeinput">Pref=[];
Pref.ItemName = <span class="string">'MyItem'</span>;
Pref.NoCells  = false;
gen_object_display(xml_read(<span class="string">'test.xml'</span>, Pref))
</pre><pre class="codeoutput">    a: [1x2 cell] = 
       b: 'jack'

       c: 'john'

</pre><h2>"Pref.Str2Num" flag in xml_read<a name="28"></a></h2>
         <p><b>Create a cell/struct mixture object</b></p><pre class="codeinput">MyTree = [];
MyTree.str     = <span class="string">'sphere'</span>;
MyTree.num1    =  123;
MyTree.num2    = <span class="string">'123'</span>;
MyTree.calc    = <span class="string">'1+2+3+4'</span>;
MyTree.func    = <span class="string">'sin(pi)/2'</span>;
MyTree.String1 = <span class="string">'[2003 10 30]'</span>;
MyTree.String2 = <span class="string">'2003 10 30'</span>;   <span class="comment">% array resembling date</span>
MyTree.ISO8601 = <span class="string">'2003-10-30'</span>;   <span class="comment">% date in ISO 8601 format</span>
MyTree.US_date = <span class="string">'2003/10/30'</span>;      <span class="comment">% US style date format year/</span>
MyTree.complex = <span class="string">'2003i-10e-30'</span>; <span class="comment">% complex number resembling date</span>
gen_object_display(MyTree);
</pre><pre class="codeoutput">        str: 'sphere'
       num1: [123]
       num2: '123'
       calc: '1+2+3+4'
       func: 'sin(pi)/2'
    String1: '[2003 10 30]'
    String2: '2003 10 30'
    ISO8601: '2003-10-30'
    US_date: '2003/10/30'
    complex: '2003i-10e-30'
</pre><p><b>Save it to xml file, using 'item' notation but with different name</b></p><pre class="codeinput">xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;str&gt;sphere&lt;/str&gt;
   &lt;num1&gt;123&lt;/num1&gt;
   &lt;num2&gt;123&lt;/num2&gt;
   &lt;calc&gt;1+2+3+4&lt;/calc&gt;
   &lt;func&gt;sin(pi)/2&lt;/func&gt;
   &lt;String1&gt;[2003 10 30]&lt;/String1&gt;
   &lt;String2&gt;2003 10 30&lt;/String2&gt;
   &lt;ISO8601&gt;2003-10-30&lt;/ISO8601&gt;
   &lt;US_date&gt;2003/10/30&lt;/US_date&gt;
   &lt;complex&gt;2003i-10e-30&lt;/complex&gt;
&lt;/MyTree&gt;
</pre><p><b>Read above file with default settings</b> ("Pref.Str2Num = true" or "Pref.Str2Num = 'smart'"). Under this setting all strings that look like numbers are converted
            to numbers, except for strings that are recognized by MATLAB 'datenum' function as dates
         </p><pre class="codeinput">gen_object_display(xml_read(<span class="string">'test.xml'</span>))
</pre><pre class="codeoutput">        str: 'sphere'
       num1: [123]
       num2: [123]
       calc: [10]
       func: 'sin(pi)/2'
    String1: [2003    10    30]
    String2: [2003    10    30]
    ISO8601: '2003-10-30'
    US_date: '2003/10/30'
    complex: [-1e-029+2003i]
</pre><p><b>Note that all the fields of 'MyTree' can be converted to numbers (even 'sphere') but by default the function is trying to
               'judge' if a string should be converted to a number or not</b></p><pre class="codeinput">MyCell = {<span class="string">'sphere'</span>,<span class="string">'1+2+3+4'</span>,<span class="string">'sin(pi)/2'</span>,<span class="string">'2003 10 30'</span>,<span class="string">'2003-10-30'</span>,<span class="string">'2003/10/30'</span>,<span class="string">'2003i-10e-30'</span>};
cellfun(@str2num, MyCell, <span class="string">'UniformOutput'</span>, false)
</pre><pre class="codeoutput">ans = 
    [21x21 double]    [10]    [6.1232e-017]    [1x3 double]    [1963]    [6.6767]    [-1.0000e-029 +2.0030e+003i]
</pre><p><b>Read above file with "Pref.Str2Num = false" or "Pref.Str2Num = 'never'" to keep all the fields in string format</b></p><pre class="codeinput">Pref=[]; Pref.Str2Num = false;
gen_object_display(xml_read(<span class="string">'test.xml'</span>, Pref))
</pre><pre class="codeoutput">        str: 'sphere'
       num1: '123'
       num2: '123'
       calc: '1+2+3+4'
       func: 'sin(pi)/2'
    String1: '[2003 10 30]'
    String2: '2003 10 30'
    ISO8601: '2003-10-30'
    US_date: '2003/10/30'
    complex: '2003i-10e-30'
</pre><p><b>Read above file with "Pref.Str2Num = always" to convert all strings that look like numbers to numbers</b> note the likelly unintendet conversion of 'ISO8601'
         </p><pre class="codeinput">Pref=[]; Pref.Str2Num   = <span class="string">'always'</span>;
gen_object_display(xml_read(<span class="string">'test.xml'</span>, Pref))
</pre><pre class="codeoutput">        str: 'sphere'
       num1: [123]
       num2: [123]
       calc: [10]
       func: 'sin(pi)/2'
    String1: [2003    10    30]
    String2: [2003    10    30]
    ISO8601: [1963]
    US_date: '2003/10/30'
    complex: [-1e-029+2003i]
</pre><p><b>Notice that all three settings will produce the same output for "num1" and "num2" and there is no way to reproduce the original
               "MyTree" structure.</b></p>
         <h2>Write XML files with ATTRIBUTEs<a name="35"></a></h2>
         <p>In order to add node attributes a special ATTRIBUTE and CONTENT fields are used.</p><pre class="codeinput">MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString.CONTENT = <span class="string">'Hello World'</span>;
MyTree.MyString.ATTRIBUTE.Num = 2;
xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString Num="2"&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><p><b>Same operation using Apache Xerces XML engine</b></p><pre class="codeinput">Pref=[]; Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
xml_write(<span class="string">'test.xml'</span>, MyTree, [], Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;MyTree&gt;
    &lt;MyNumber&gt;13&lt;/MyNumber&gt;
    &lt;MyString Num="2"&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;

</pre><h2>Write XML files with COMMENTs<a name="37"></a></h2>
         <p>Insertion of Comments is done with help of special COMMENT field. Note that MATLAB's xmlwrite is less readable due to lack
            of end-of-line characters around comment section.
         </p><pre class="codeinput">MyTree=[];
MyTree.COMMENT = <span class="string">'This is a comment'</span>;
MyTree.MyNumber = 13;
MyTree.MyString.CONTENT = <span class="string">'Hello World'</span>;
xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;&lt;!--This is a comment--&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><p><b>Same operation using Apache Xerces XML engine</b> gives the same result
         </p><pre class="codeinput">Pref=[]; Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>, Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;MyTree&gt;
    &lt;!--This is a comment--&gt;
    &lt;MyNumber&gt;13&lt;/MyNumber&gt;
    &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;

</pre><p><b>Comments in XML top level (method #1)</b> This method uses cell array
         </p><pre class="codeinput">MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString = <span class="string">'Hello World'</span>;
xml_write(<span class="string">'test.xml'</span>, MyTree, {<span class="string">'MyTree'</span>, [], <span class="string">'This is a global comment'</span>});
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!--This is a global comment--&gt;
&lt;MyTree&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><p><b>Same operation using Apache Xerces XML engine</b> gives even nicer results.
         </p><pre class="codeinput">Pref=[]; Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
xml_write(<span class="string">'test.xml'</span>, MyTree, {<span class="string">'MyTree'</span>, [], <span class="string">'This is a global comment'</span>}, Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!--This is a global comment--&gt;
&lt;MyTree&gt;
    &lt;MyNumber&gt;13&lt;/MyNumber&gt;
    &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;

</pre><p><b>Comments in XML top level (method #2)</b> This method adds an extra top layer to the struct 'tree' and sets "Pref.RootOnly = false", which informs the function about
            the extra layer. Notice that RootName is also saved as a part of the 'tree', and does not have to be passed in separately.
         </p><pre class="codeinput">MyTree=[];
MyTree.COMMENT = <span class="string">'This is a global comment'</span>;
MyTree.MyTest.MyNumber = 13;
MyTree.MyTest.MyString = <span class="string">'Hello World'</span>;
Pref=[]; Pref.RootOnly = false;
xml_write(<span class="string">'test.xml'</span>, MyTree, [], Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!--This is a global comment--&gt;
&lt;MyTest&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTest&gt;
</pre><p><b>Same operation using Apache Xerces XML engine</b></p><pre class="codeinput">Pref=[]; Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
Pref.RootOnly  = false;
xml_write(<span class="string">'test.xml'</span>, MyTree, [], Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!--This is a global comment--&gt;
&lt;MyTest&gt;
    &lt;MyNumber&gt;13&lt;/MyNumber&gt;
    &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTest&gt;

</pre><h2>Write XML files with PROCESSING_INSTRUCTIONs<a name="43"></a></h2>
         <p>Insertion of Processing Instructions is done through use of special PROCESSING_INSTRUCTION field, which stores the instruction
            string. The string has to be in 'target data' format separated by space.
         </p><pre class="codeinput">MyTree=[];
MyTree.PROCESSING_INSTRUCTION = <span class="string">'xml-stylesheet type="a" href="foo"'</span>;
MyTree.MyNumber = 13;
MyTree.MyString = <span class="string">'Hello World'</span>;
xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;&lt;?xml-stylesheet type="a" href="foo"?&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><p><b>Same operation using Apache Xerces XML engine</b></p><pre class="codeinput">Pref=[]; Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>, Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;MyTree&gt;&lt;?xml-stylesheet type="a" href="foo"?&gt;
    &lt;MyNumber&gt;13&lt;/MyNumber&gt;
    &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;

</pre><p><b>PROCESSING_INSTRUCTIONs in XML top level (method #1)</b> This method uses cell array
         </p><pre class="codeinput">MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString = <span class="string">'Hello World'</span>;
xml_write(<span class="string">'test.xml'</span>, MyTree, {<span class="string">'MyTree'</span>, <span class="string">'xml-stylesheet type="a" href="foo"'</span>});
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;?xml-stylesheet type="a" href="foo"?&gt;
&lt;MyTree&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><p><b>Same operation using Apache Xerces XML engine</b></p><pre class="codeinput">Pref=[]; Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
xml_write(<span class="string">'test.xml'</span>, MyTree, {<span class="string">'MyTree'</span>, <span class="string">'xml-stylesheet type="a" href="foo"'</span>}, Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?xml-stylesheet type="a" href="foo"?&gt;
&lt;MyTree&gt;
    &lt;MyNumber&gt;13&lt;/MyNumber&gt;
    &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;

</pre><p><b>PROCESSING_INSTRUCTIONs in XML top level (method #2)</b> This method adds an extra top layer to the struct 'tree' and sets pref.RootOnly=false, which informs the function about the
            extra layer. Notice that RootName is also saved as a part of the 'tree', and does not have to be passed in separately.
         </p><pre class="codeinput">MyTree=[];
MyTree.PROCESSING_INSTRUCTION =  <span class="string">'xml-stylesheet type="a" href="foo"'</span>;
MyTree.MyTest.MyNumber = 13;
MyTree.MyTest.MyString = <span class="string">'Hello World'</span>;
Pref=[]; Pref.RootOnly = false;
xml_write(<span class="string">'test.xml'</span>, MyTree, [], Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;?xml-stylesheet type="a" href="foo"?&gt;
&lt;MyTest&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTest&gt;
</pre><p><b>Same operation using Apache Xerces XML engine</b></p><pre class="codeinput">Pref=[]; Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
Pref.RootOnly  = false;
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>, Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?xml-stylesheet type="a" href="foo"?&gt;
&lt;MyTest&gt;
    &lt;MyNumber&gt;13&lt;/MyNumber&gt;
    &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTest&gt;

</pre><h2>Write XML files with CDATA Sections<a name="49"></a></h2>
         <p>"In an XML document a CDATA (Character DATA) section is a section of  element content that is marked for the parser to interpret
            as only  character data, not markup." (from Wikipedia) To insert CDATA Sections one use special CDATA_SECTION field,  which
            stores the instruction string. Note that MATLAB's xmlwrite created  wrong xml code for CDATA section
         </p><pre class="codeinput">MyTree=[];
MyTree.CDATA_SECTION = <span class="string">'&lt;A&gt;txt&lt;/A&gt;'</span>;
MyTree.MyNumber = 13;
MyTree.MyString = <span class="string">'Hello World'</span>;
xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;&amp;lt;A&amp;gt;txt&amp;lt;/A&amp;gt;&lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><p><b>Same operation using Apache Xerces XML engine produces correct results</b></p><pre class="codeinput">Pref=[]; Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>, Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;MyTree&gt;&lt;![CDATA[&lt;A&gt;txt&lt;/A&gt;]]&gt;&lt;MyNumber&gt;13&lt;/MyNumber&gt;
    &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;

</pre><h2>Write XML files with special characters in TAG names<a name="51"></a></h2>
         <p>The input to xml_write requires that all tags one wants in XML document have to be encoded as field names of MATLAB's struct's.
            Matlab has a lot of restrictions on variable names. This section is about XML tags with names not allowed as MATLAB variables,
            or more specifically with characters allowed as xml tag names but not allowed as MATLAB variable names. Characters like that
            can be replaced by their hexadecimal representation just as it is done by genvarname function. Alternative way of writing
            the first example is:
         </p><pre class="codeinput">MyTree=[];
MyTree.(<span class="string">'MyNumber'</span>) = 13;               <span class="comment">% same as MyTree.MyNumber = 13;</span>
MyTree.MyString.CONTENT = <span class="string">'Hello World'</span>;
MyTree.MyString.ATTRIBUTE.(<span class="string">'Num'</span>) = 2;  <span class="comment">% same as MyTree.MyString.ATTRIBUTE.Num = 2;</span>
xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString Num="2"&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><p><b>This approach fails for some characters like dash '-', colon ':', and international characters.</b></p><pre class="codeinput">MyTree=[];
<span class="keyword">try</span>
  MyTree.(<span class="string">'My-Number'</span>) = 13;
  MyTree.MyString.CONTENT = <span class="string">'Hello World'</span>;
  MyTree.MyString.ATTRIBUTE.(<span class="string">'Num_&ouml;'</span>) = 2;
<span class="keyword">catch</span>
  err = lasterror;
  disp(err.message);
<span class="keyword">end</span>
</pre><pre class="codeoutput">Invalid field name: 'My-Number'.
</pre><p>It can be overcome by replacing offending characters with their hexadecimal representation. That can be done manually or with
            use of genvarname function. Note that MATLAB 'type' function does not show correctly '&ouml;' letter in xml file, but opening the
            file in editor shows that it is correct.
         </p><pre class="codeinput">MyTree=[];
MyTree.(genvarname(<span class="string">'My-Number'</span>)) = 13;
MyTree.MyString.CONTENT = <span class="string">'Hello World'</span>;
MyTree.MyString.ATTRIBUTE.Num_0xF6 = 2;
gen_object_display(MyTree);
xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">    My0x2DNumber: [13]
        MyString: [1x1 struct]
                    CONTENT: 'Hello World'
                  ATTRIBUTE: [1x1 struct]
                             Num_0xF6: [2]

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;My-Number&gt;13&lt;/My-Number&gt;
   &lt;MyString Num_&Atilde;&para;="2"&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><p><b>Also two of the characters '-' and ':' can be encoded by a special strings: '_DASH_' and '_COLON_' respectively</b></p><pre class="codeinput">MyTree=[];
MyTree.My_DASH_Number = 13;
MyTree.MyString.CONTENT = <span class="string">'Hello World'</span>;
MyTree.MyString.ATTRIBUTE.Num0xF6 = 2;
xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;My-Number&gt;13&lt;/My-Number&gt;
   &lt;MyString Num&Atilde;&para;="2"&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><h2>Write XML files with Namespaces<a name="55"></a></h2>
         <p>No extra special fields are needed to define XML namespaces, only colon character written using '0x3A' or '_COLON_'. Below
            is an example of a namespace definition
         </p><pre class="codeinput">MyTree=[];
MyTree.f_COLON_child.ATTRIBUTE.xmlns_COLON_f = <span class="string">'http://www.foo.com'</span>;
MyTree.f_COLON_child.f_COLON_MyNumber = 13;
MyTree.f_COLON_child.f_COLON_MyString = <span class="string">'Hello World'</span>;
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;f:child xmlns:f="http://www.foo.com"&gt;
      &lt;f:MyNumber&gt;13&lt;/f:MyNumber&gt;
      &lt;f:MyString&gt;Hello World&lt;/f:MyString&gt;
   &lt;/f:child&gt;
&lt;/MyTree&gt;
</pre><p><b>Same operation using Apache Xerces XML engine</b></p><pre class="codeinput">Pref=[]; Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'f_COLON_MyTree'</span>, Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;f:MyTree&gt;
    &lt;f:child xmlns:f="http://www.foo.com"&gt;
        &lt;f:MyNumber&gt;13&lt;/f:MyNumber&gt;
        &lt;f:MyString&gt;Hello World&lt;/f:MyString&gt;
    &lt;/f:child&gt;
&lt;/f:MyTree&gt;

</pre><h2>"Pref.KeepNS" flag in "xml_read"<a name="57"></a></h2>
         <p>Thise option allow keeping  or exclusion of namespaces in tag names. By default the namespace data is kept but it produces
            much longer field names in the output structure. Ignoring namespace will produce more readible output. Perform default read
            of file with namespace
         </p><pre class="codeinput">tree = xml_read(<span class="string">'test.xml'</span>);
gen_object_display(tree);
</pre><pre class="codeoutput">    f_COLON_child: [1x1 struct]
                   f_COLON_MyNumber: [13]
                   f_COLON_MyString: 'Hello World'
                          ATTRIBUTE: [1x1 struct]
                                     xmlns_COLON_f: 'http://www.foo.com'
</pre><p>Now the same operation with KeepNS = false.</p><pre class="codeinput">Pref=[]; Pref.KeepNS = false; <span class="comment">% do not read attributes</span>
tree = xml_read(<span class="string">'test.xml'</span>, Pref);
gen_object_display(tree);
</pre><pre class="codeoutput">    child: [1x1 struct]
            MyNumber: [13]
            MyString: 'Hello World'
           ATTRIBUTE: [1x1 struct]
                      f: 'http://www.foo.com'
</pre><h2>Read XML files with special node types<a name="59"></a></h2>
         <p>Display and read the file, then show the data structure. Note that MATLAB 'type' function shows '&ouml;' letter incorrectly as
            'A&para;' in xml file, but opening the file in editor shows that it is correct.
         </p><pre class="codeinput">fprintf(<span class="string">'Test xml file:\n'</span>);
type(<span class="string">'test_file.xml'</span>)
</pre><pre class="codeoutput">Test xml file:

&lt;?xml version="1.0" encoding="utf-8" ?&gt; 
&lt;?xml-stylesheet type="text/css" href="foo.css"?&gt;
&lt;!-- This is a Global Comment --&gt;
&lt;aaa xmlns:xsi="http://www.foo.org"&gt;
  &lt;?ProcInst type="local processing instruction"?&gt;
  &lt;!-- local comment 1 --&gt;
  bbb
  &lt;!-- local comment 2 --&gt;
  ccc
  &lt;matrix bad-name='fff'&gt;
    5e3+2*i, Inf
    NaN,     pi
  &lt;/matrix&gt;
  &lt;ee_e&gt; ee_e &lt;/ee_e&gt;
  &lt;ff-f&gt; ff-f &lt;/ff-f&gt;
  &lt;gg&Atilde;&para;g&gt; gg&Atilde;&para;g &lt;/gg&Atilde;&para;g&gt;
  &lt;![CDATA[
    Here &lt;ddd&gt;xml&lt;/ddd&gt; tags are treated as ...
    ... text
	]]&gt;
&lt;/aaa&gt;


</pre><p>Read only the Root Element (default)</p><pre class="codeinput">[tree GlobalTextNodes] = xml_read(<span class="string">'test_file.xml'</span>);
fprintf(<span class="string">'Global Data (Root name, Global Processing Instructions and Global Comments):\n'</span>);
disp(GlobalTextNodes')
fprintf(<span class="string">'\nStructure read from the file (uncludes COMMENT and CDATA sections):\n'</span>);
gen_object_display(tree);
</pre><pre class="codeoutput">Global Data (Root name, Global Processing Instructions and Global Comments):
    'aaa'
    'xml-stylesheet type="text/css" href="foo.css"'
    'This is a Global Comment'

Structure read from the file (uncludes COMMENT and CDATA sections):
    PROCESSING_INSTRUCTION: 'ProcInst type="local processing instruction"'
                   COMMENT: [1x2 cell] = 
                            local comment 1

                            local comment 2

                   CONTENT: [1x2 cell] = 
                            bbb

                            ccc

                    matrix: [1x1 struct]
                              CONTENT: [2x2 double]
                            ATTRIBUTE: [1x1 struct]
                                       bad_DASH_name: 'fff'
                      ee_e: 'ee_e'
                 ff_DASH_f: 'ff-f'
                   gg0xF6g: 'gg&ouml;g'
             CDATA_SECTION: 'Here &lt;ddd&gt;xml&lt;/ddd&gt; tags are treated as ...
    ... text'
                 ATTRIBUTE: [1x1 struct]
                            xmlns_COLON_xsi: 'http://www.foo.org'
</pre><p>Read the whole tree including global Comments and Processing Instructions</p><pre class="codeinput">Pref=[]; Pref.RootOnly = false;
[tree GlobalTextNodes] = xml_read(<span class="string">'test_file.xml'</span>, Pref);
fprintf(<span class="string">'Global Data (Root name, Global Processing Instructions and Global Comments):\n'</span>);
disp(GlobalTextNodes')
fprintf(<span class="string">'\nStructure read from the file (uncludes COMMENT and CDATA sections):\n'</span>);
gen_object_display(tree);
</pre><pre class="codeoutput">Global Data (Root name, Global Processing Instructions and Global Comments):
    'aaa'
    'xml-stylesheet type="text/css" href="foo.css"'
    'This is a Global Comment'

Structure read from the file (uncludes COMMENT and CDATA sections):
    PROCESSING_INSTRUCTION: 'xml-stylesheet type="text/css" href="foo.css"'
                   COMMENT: 'This is a Global Comment'
                       aaa: [1x1 struct]
                            PROCESSING_INSTRUCTION: 'ProcInst type="local processing instruction"'
                                           COMMENT: [1x2 cell] = 
                                                    local comment 1

                                                    local comment 2

                                           CONTENT: [1x2 cell] = 
                                                    bbb

                                                    ccc

                                            matrix: [1x1 struct]
                                                      CONTENT: [2x2 double]
                                                    ATTRIBUTE: [1x1 struct]
                                                               bad_DASH_name: 'fff'
                                              ee_e: 'ee_e'
                                         ff_DASH_f: 'ff-f'
                                           gg0xF6g: 'gg&ouml;g'
                                     CDATA_SECTION: 'Here &lt;ddd&gt;xml&lt;/ddd&gt; tags are treated as ...
    ... text'
                                         ATTRIBUTE: [1x1 struct]
                                                    xmlns_COLON_xsi: 'http://www.foo.org'
</pre><h2>"Pref.ReadAttr" flag in "xml_read"<a name="62"></a></h2>
         <p>Those option allow exclusion of attributes</p><pre class="codeinput">Pref=[]; Pref.ReadAttr = false; <span class="comment">% do not read attributes</span>
tree = xml_read(<span class="string">'test_file.xml'</span>, Pref);
gen_object_display(tree);
</pre><pre class="codeoutput">    PROCESSING_INSTRUCTION: 'ProcInst type="local processing instruction"'
                   COMMENT: [1x2 cell] = 
                            local comment 1

                            local comment 2

                   CONTENT: [1x2 cell] = 
                            bbb

                            ccc

                    matrix: [2x2 double]
                      ee_e: 'ee_e'
                 ff_DASH_f: 'ff-f'
                   gg0xF6g: 'gg&ouml;g'
             CDATA_SECTION: 'Here &lt;ddd&gt;xml&lt;/ddd&gt; tags are treated as ...
    ... text'
</pre><h2>"Pref.ReadSpec" flag in "xml_read"<a name="63"></a></h2>
         <p>Those option allow exclusion of special nodes, like comments, processing instructions, CData sections, etc.</p><pre class="codeinput">Pref=[]; Pref.ReadSpec = false; <span class="comment">% do not read special node types</span>
tree = xml_read(<span class="string">'test_file.xml'</span>, Pref);
gen_object_display(tree);
</pre><pre class="codeoutput">      CONTENT: [1x2 cell] = 
               bbb

               ccc

       matrix: [1x1 struct]
                 CONTENT: [2x2 double]
               ATTRIBUTE: [1x1 struct]
                          bad_DASH_name: 'fff'
         ee_e: 'ee_e'
    ff_DASH_f: 'ff-f'
      gg0xF6g: 'gg&ouml;g'
    ATTRIBUTE: [1x1 struct]
               xmlns_COLON_xsi: 'http://www.foo.org'
</pre><h2>"Pref.RootOnly" flag in "xml_read"<a name="64"></a></h2>
         <p>As it was shown in previous examples RootOnly parameter can be used to capture global (top level) special nodes (like COMMENTs
            and PROCESSING_INSTRUCTIONs) which are ignored by default
         </p><pre class="codeinput">Pref=[]; Pref.RootOnly = false; <span class="comment">% do not read special node types</span>
tree = xml_read(<span class="string">'test_file.xml'</span>, Pref);
gen_object_display(tree);
</pre><pre class="codeoutput">    PROCESSING_INSTRUCTION: 'xml-stylesheet type="text/css" href="foo.css"'
                   COMMENT: 'This is a Global Comment'
                       aaa: [1x1 struct]
                            PROCESSING_INSTRUCTION: 'ProcInst type="local processing instruction"'
                                           COMMENT: [1x2 cell] = 
                                                    local comment 1

                                                    local comment 2

                                           CONTENT: [1x2 cell] = 
                                                    bbb

                                                    ccc

                                            matrix: [1x1 struct]
                                                      CONTENT: [2x2 double]
                                                    ATTRIBUTE: [1x1 struct]
                                                               bad_DASH_name: 'fff'
                                              ee_e: 'ee_e'
                                         ff_DASH_f: 'ff-f'
                                           gg0xF6g: 'gg&ouml;g'
                                     CDATA_SECTION: 'Here &lt;ddd&gt;xml&lt;/ddd&gt; tags are treated as ...
    ... text'
                                         ATTRIBUTE: [1x1 struct]
                                                    xmlns_COLON_xsi: 'http://www.foo.org'
</pre><h2>"Pref.RootOnly" flag in "xml_write"<a name="65"></a></h2>
         <p>Writing previously read tree with default "Pref.RootOnly = true" gives wrong output file</p><pre class="codeinput">Pref=[]; Pref.RootOnly = true; <span class="comment">% do not read special node types</span>
xml_write(<span class="string">'test.xml'</span>, tree, [], Pref);
fprintf(<span class="string">'Test xml file:\n'</span>);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">Test xml file:

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;tree&gt;&lt;?xml-stylesheet type="text/css" href="foo.css"?&gt;&lt;!--This is a Global Comment--&gt;
   &lt;aaa xmlns:xsi="http://www.foo.org"&gt;&lt;?ProcInst type="local processing instruction"?&gt;&lt;!--local comment 1--&gt;&lt;!--local comment 2--&gt;
      &lt;item&gt;bbb&lt;/item&gt;
      &lt;item&gt;ccc&lt;/item&gt;
      &lt;matrix bad-name="fff"&gt;[5000+i*2 Inf; NaN 3.14159265358979]&lt;/matrix&gt;
      &lt;ee_e&gt;ee_e&lt;/ee_e&gt;
      &lt;ff-f&gt;ff-f&lt;/ff-f&gt;
      &lt;gg&Atilde;&para;g&gt;gg&Atilde;&para;g&lt;/gg&Atilde;&para;g&gt;Here &amp;lt;ddd&amp;gt;xml&amp;lt;/ddd&amp;gt; tags are treated as ...
    ... text&lt;/aaa&gt;
&lt;/tree&gt;
</pre><p>Writing the same tree with "Pref.RootOnly = false" gives correct output</p><pre class="codeinput">Pref=[]; Pref.RootOnly = false; <span class="comment">% do not read special node types</span>
xml_write(<span class="string">'test.xml'</span>, tree, [], Pref);
fprintf(<span class="string">'Test xml file:\n'</span>);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">Test xml file:

&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;?xml-stylesheet type="text/css" href="foo.css"?&gt;&lt;!--This is a Global Comment--&gt;
&lt;aaa xmlns:xsi="http://www.foo.org"&gt;&lt;?ProcInst type="local processing instruction"?&gt;&lt;!--local comment 1--&gt;&lt;!--local comment 2--&gt;
   &lt;item&gt;bbb&lt;/item&gt;
   &lt;item&gt;ccc&lt;/item&gt;
   &lt;matrix bad-name="fff"&gt;[5000+i*2 Inf; NaN 3.14159265358979]&lt;/matrix&gt;
   &lt;ee_e&gt;ee_e&lt;/ee_e&gt;
   &lt;ff-f&gt;ff-f&lt;/ff-f&gt;
   &lt;gg&Atilde;&para;g&gt;gg&Atilde;&para;g&lt;/gg&Atilde;&para;g&gt;Here &amp;lt;ddd&amp;gt;xml&amp;lt;/ddd&amp;gt; tags are treated as ...
    ... text&lt;/aaa&gt;
</pre><h2>"Pref.NumLevels" flag in "xml_read"<a name="67"></a></h2>
         <p>This parameter allows user to skip parts of the tree in order to save time and memory. Usefull only in a rare case when a
            small portion of large XML file is needed.
         </p>
         <p>Create test tile</p><pre class="codeinput">MyTree = [];
MyTree.Level1 = 1;
MyTree.Level1_.Level2 = 2;
MyTree.Level1_.Level2_.Level3 = 3;
MyTree.Level1_.Level2_.Level3_.Level4 = 4;
xml_write(<span class="string">'test.xml'</span>, MyTree);
fprintf(<span class="string">'Test xml file:\n'</span>);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">Test xml file:

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;Level1&gt;1&lt;/Level1&gt;
   &lt;Level1_&gt;
      &lt;Level2&gt;2&lt;/Level2&gt;
      &lt;Level2_&gt;
         &lt;Level3&gt;3&lt;/Level3&gt;
         &lt;Level3_&gt;
            &lt;Level4&gt;4&lt;/Level4&gt;
         &lt;/Level3_&gt;
      &lt;/Level2_&gt;
   &lt;/Level1_&gt;
&lt;/MyTree&gt;
</pre><p><b>Use Default ("Pref.NumLevels = infinity") setting</b></p><pre class="codeinput">tree = xml_read(<span class="string">'test.xml'</span>);
gen_object_display(tree);
</pre><pre class="codeoutput">     Level1: [1]
    Level1_: [1x1 struct]
              Level2: [2]
             Level2_: [1x1 struct]
                       Level3: [3]
                      Level3_: [1x1 struct]
                               Level4: [4]
</pre><p><b>Limit the read to only 2 levels</b></p><pre class="codeinput">Pref=[]; Pref.NumLevels = 2;
tree = xml_read(<span class="string">'test.xml'</span>, Pref);
gen_object_display(tree);
</pre><pre class="codeoutput">     Level1: [1]
    Level1_: [1x1 struct]
              Level2: [2]
             Level2_: [0x0 double]
</pre><h2>Create DOM object based on a Struct using "xml_write"<a name="70"></a></h2>
         <p><b>Create Struct tree</b></p><pre class="codeinput">MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString = <span class="string">'Hello World'</span>;
</pre><p><b>Convert Struct to DOM object using xml_write</b></p><pre class="codeinput">DOM = xml_write([], MyTree);
xmlwrite(<span class="string">'test.xml'</span>, DOM);   <span class="comment">% Save DOM object using MATLAB function</span>
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><h2>Convert DOM object to Struct using "xml_read"<a name="72"></a></h2><pre class="codeinput">DOM = xmlread(<span class="string">'test.xml'</span>);       <span class="comment">% Read DOM object using MATLAB function</span>
[tree treeName] = xml_read(DOM); <span class="comment">% Convert DOM object to Struct</span>
disp([treeName{1} <span class="string">' ='</span>])
gen_object_display(tree)
</pre><pre class="codeoutput">MyTree =
    MyNumber: [13]
    MyString: 'Hello World'
</pre><h2>Write XML file based on a DOM using "xml_write_xerces"<a name="73"></a></h2><pre class="codeinput">xmlwrite_xerces(<span class="string">'test.xml'</span>, DOM); <span class="comment">% Save DOM object using Xerces library</span>
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;MyTree&gt;
    &lt;MyNumber&gt;13&lt;/MyNumber&gt;
    &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;

</pre><h2>Write XML to string instead of a file<a name="74"></a></h2><pre class="codeinput">DOM = xml_write([], MyTree);
str = xmlwrite(DOM);
disp(str)
</pre><pre class="codeoutput">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><p class="footer"><br>
            Published with MATLAB&reg; 7.6<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Tutorial for xml_io_tools Package
% *By Jarek Tuszynski*
%
% Package xml_io_tools can read XML files into MATLAB struct and writes 
% MATLAB data types to XML files with help of simple interface to 
% MATLAB's xmlwrite and xmlread functions.
% 
% Two function to simplify reading and writing XML files from MATLAB:
%
% * Function xml_read first calls MATLAB's xmlread function and than 
% converts its output ('Document Object Model' tree of Java objects) 
% to tree of MATLAB struct's. The output is in the format of nested 
% structs and cells. In the output data structure field names are based on
% XML tags.
%
% * Function xml_write first convert input tree of MATLAB structs and cells 
% and other types to tree of 'Document Object Model' nodes, and then writes 
% resulting object to XML file using MATLAB's xmlwrite function. .
%
%% This package can:
% * Read most XML files, created inside and outside of MATLAB, and 
%   convert them to MATLAB data structures.
% * Write any MATLAB's struct tree to XML file
% * Handle XML attributes in the same way as xml_toolbox package
% * Handle special XML nodes like comments, processing instructions and 
%   CDATA sections
% * Be studied, modified, customized, rewritten and used in other packages 
%   without any limitations. All code is included and documented. Software
%   is distributed under MIT Licence (included).   
%
%% This package does not:
% * Guarantee to recover the same Matlab objects that were saved. If you 
% need to be able to recover carbon copy of the structure that was saved 
% than you will have to use one of the packages that uses special set of 
% tags saved as xml attributes that help to guide the parsing of XML code. 
% This package does not do that.
% * Guarantee to work with older versions of MATLAB. Functions do not work
% with versions of MATLAB prior to 7.1 (26-Jul-2005). Versions starting 
% with 7.1 seem to work on my machine, which have current java engine and 
% libraries. 
%
%% Change History
% * 2006-11-06 - original version
% * 2006-11-26 - corrected xml_write to handle writing Matlab's column
%   arrays to xml files. Bug discovered and diagnosed by Kalyan Dutta.
% * 2006-11-28 - made changes to handle special node types like: 
%   COMMENTS and CDATA sections 
% * 2007-02-20 - Writing CDATA sections still did not worked. The problem 
%   was diagnosed and fixed by Alberto Amaro. The fix involved rewriting
%   xmlwrite to use Apache Xerces java files directly instead of MATLAB's 
%   XMLUtils java class.
% * 2007-06-20 - Fixed problem reported by Anna Kelbert in Reviews about 
%   not writing attributes of ROOT node. Also: added support for Processing
%   Instructions, added support for global text nodes: Processing
%   Instructions and comments, allowed writing tag names with special
%   characters
% * 2007-07-19 - Added tutorial script file. Extended support for global
%   text nodes. Added more Preference fields.
% * 2008-01-05 - Fixed problem reported by Anna Krewet of converting dates 
%   in format '2007-01-01' to numbers. Improved and added warning messages.
%   Added detection of old Matlab versions incompatible with the library.
%   Expanded documentation.
% * 2008-06-14 - Fixed problem with writing 1D array reported by Mark Neil. 
%   Extended xml_read's Pref.Num2Str to 3 settings (never, smart and always) 
%   for better control. Added parameter Pref.KeepNS for keeping or ignoring 
%   namespace data when reading. Fixed a bug related to writing 2D cell
%   arrays brought up by Andrej's Mosat review. 

%% Licence
% The package is distributed under MIT Licence
format compact; % viewing preference
clear variables;
type('MIT_Licence.txt')

%% Write XML file based on a Struct using "xml_write"
% Any MATLAB data struct can be saved to XML file. Notice that
% 'tree' only defines content of the root element. Its name has to be
% either passed separately or deduced from the input variable name.
MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString = 'Hello World';
xml_write('test.xml', MyTree);
type('test.xml')

%% Read XML file producing a Struct using "xml_read"
[tree treeName] = xml_read ('test.xml');
disp([treeName{1} ' ='])
gen_object_display(tree)

%% "Pref.XmlEngine" flag in "xml_write"
% Same operation using Apache Xerces XML engine. Notice that in this case root element name
% was passed as variable and not extracted from the variable name.
Pref=[]; Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
xml_write('test.xml', MyTree, 'TreeOfMine', Pref);
type('test.xml')

%% Writing Struct with MATLAB arrays
MyTree=[];
MyTree.Num_1x1 = 13;
MyTree.Vec_1x3 = [1 2 3]; 
MyTree.Vec_4x1 = [1; 2; 3; 4]; 
MyTree.Mat_2x2 = [1, 2; 3, 4];         % 2D Matrix
MyTree.Cube_3D = reshape(1:8,[2 2 2]); % 3D array
MyTree.String1 = '[2003 10 30]';       % array with    [] brackets
MyTree.String2 =  '2003 10 30';        % array without [] brackets
xml_write('test.xml', MyTree);
type('test.xml')

%% Read Struct with MATLAB arrays
% Notice that by default 'String2' was not converted to a array - see section
% on Str2Num for details. Also notice that 'Cube_3D' did not preserve
% original dimentions 
[tree treeName] = xml_read ('test.xml');
disp([treeName{1} ' ='])
gen_object_display(tree)

%% "Pref.StructItem" flag in "xml_write"
% *Create a simple structure with arrays of struct's*
MyTree = [];
MyTree.a(1).b = 'jack';
MyTree.a(2).b = 'john';
gen_object_display(MyTree)
%%
% *Write XML with "StructItem = true" (default).  Notice single 'a' 
% section and multiple 'item' sub-sections. Those subsections are used 
% to store array elements*
wPref.StructItem = true;
xml_write('test.xml', MyTree, 'MyTree',wPref);
type('test.xml')
fprintf('\nxml_read output:\n')
gen_object_display(xml_read ('test.xml'))
%%
% *Write XML with "StructItem = false". Notice multiple 'a' sections*
wPref.StructItem = false;
xml_write('test.xml', MyTree, 'MyTree',wPref);
type('test.xml')
fprintf('\nxml_read output:\n')
gen_object_display(xml_read ('test.xml'))
%%
% *Notice that xml_read function produced the same struct when reading both files*
%%
% *Potential problems with "StructItem = true":*
wPref.StructItem = true;
MyTree1 = []; MyTree1.a.b    = 'jack';
MyTree2 = []; MyTree2.a(1).b = 'jack';
MyTree3 = []; MyTree3.a(2).b = 'jack';
xml_write('test.xml', MyTree1, [], wPref); type('test.xml');
xml_write('test.xml', MyTree2, [], wPref); type('test.xml');
xml_write('test.xml', MyTree3, [], wPref); type('test.xml');
%%
% *Notice that MyTree1 and MyTree2 produce identical files with no 'items',
% while MyTree2 and MyTree3 produce very different file structures. It was
% pointed out to me that files produced from MyTree2 and MyTree3 can not 
% belong to the same schema, which can be a problem.* 


%% "Pref.CellItem" flag in "xml_write"
% *Create a simple structure with cell arrays*
MyTree = [];
MyTree.a = {'jack', 'john'};
disp(MyTree)
%%
% *Write XML with "StructItem = true" (default).  Notice single 'a' 
% section and multiple 'item' sections*
Pref=[]; Pref.CellItem = true;
xml_write('test.xml', MyTree, 'MyTree',Pref);
type('test.xml')
fprintf('\nxml_read output:\n');
disp(xml_read ('test.xml'))
%%
% *Write XML with "StructItem = false". Notice multiple 'a' sections*
Pref=[]; Pref.CellItem = false;
xml_write('test.xml', MyTree, 'MyTree',Pref);
type('test.xml')
fprintf('\nxml_read output:\n');
disp(xml_read ('test.xml'))
%%
% *Notice that xml_read function produced the same struct when reading both files*


%% "Pref.NoCells" flag in "xml_read"
% *Create a cell/struct mixture object*
MyTree = [];
MyTree.a{1}.b = 'jack';
MyTree.a{2}.b = [];
MyTree.a{2}.c = 'john';
gen_object_display(MyTree);
%%
% *Save it to xml file*
Pref=[]; Pref.CellItem = false;
xml_write('test.xml', MyTree, 'MyTree',Pref);
type('test.xml')
%%
% *Read above file with "Pref.NoCells=true" (default) - output is quite different then input*
% By default program is trying to convert everything to struct's and arrays
% of structs. In case arrays of structs all the structs in array need to have the
% same fields, and if they are not than MATLAB creates empty fields.
Pref=[]; Pref.NoCells=true;
gen_object_display(xml_read('test.xml', Pref))
%%
% *Read above file with "Pref.NoCells=false" - now input and output are the same*
% Cell arrays of structs allow structs in array to have different fields.
Pref=[]; Pref.NoCells=false;
gen_object_display(xml_read('test.xml', Pref))

%% "Pref.ItemName" flag in "xml_write"
% *Create a cell/struct mixture object*
MyTree = [];
MyTree.a{1}.b = 'jack';
MyTree.a{2}.c = 'john';
gen_object_display(MyTree);
%%
% *Save it to xml file, using 'item' notation but with different name*
Pref=[]; 
Pref.CellItem = true;
Pref.ItemName = 'MyItem';
xml_write('test.xml', MyTree, 'MyTree',Pref);
type('test.xml')

%% "Pref.ItemName" flag in "xml_read"
% *Read above file with default settings ("Pref.ItemName = 'item'")*
% The results do not match the original structure
Pref=[]; Pref.NoCells  = false;
gen_object_display(xml_read('test.xml', Pref))
%%
% *Read above file with "Pref.ItemName = 'MyItem'" - now saved and read 
% MATLAB structures are the same*
Pref=[]; 
Pref.ItemName = 'MyItem';
Pref.NoCells  = false;
gen_object_display(xml_read('test.xml', Pref))


%% "Pref.Str2Num" flag in xml_read
% *Create a cell/struct mixture object*
MyTree = [];
MyTree.str     = 'sphere';
MyTree.num1    =  123;
MyTree.num2    = '123';
MyTree.calc    = '1+2+3+4';
MyTree.func    = 'sin(pi)/2';
MyTree.String1 = '[2003 10 30]'; 
MyTree.String2 = '2003 10 30';   % array resembling date
MyTree.ISO8601 = '2003-10-30';   % date in ISO 8601 format
MyTree.US_date = '2003/10/30';      % US style date format year/
MyTree.complex = '2003i-10e-30'; % complex number resembling date
gen_object_display(MyTree);
%%
% *Save it to xml file, using 'item' notation but with different name*
xml_write('test.xml', MyTree);
type('test.xml')
%%
% *Read above file with default settings*
% ("Pref.Str2Num = true" or "Pref.Str2Num = 'smart'"). Under this setting all
% strings that look like numbers are converted to numbers, except for 
% strings that are recognized by MATLAB 'datenum' function as dates
gen_object_display(xml_read('test.xml'))
%%
% *Note that all the fields of 'MyTree' can be converted to numbers (even 
% 'sphere') but by default the function is trying to 'judge' if a string  
% should be converted to a number or not*
MyCell = {'sphere','1+2+3+4','sin(pi)/2','2003 10 30','2003-10-30','2003/10/30','2003i-10e-30'};
cellfun(@str2num, MyCell, 'UniformOutput', false)
%%
% *Read above file with "Pref.Str2Num = false" or "Pref.Str2Num = 'never'" 
% to keep all the fields in string format*
Pref=[]; Pref.Str2Num = false;
gen_object_display(xml_read('test.xml', Pref))
%%
% *Read above file with "Pref.Str2Num = always"  
% to convert all strings that look like numbers to numbers* note the likelly 
% unintendet conversion of 'ISO8601'
Pref=[]; Pref.Str2Num   = 'always';
gen_object_display(xml_read('test.xml', Pref))
%%
% *Notice that all three settings will produce the same output for "num1" and
% "num2" and there is no way to reproduce the original "MyTree" structure.*

%% Write XML files with ATTRIBUTEs 
% In order to add node attributes a special ATTRIBUTE and CONTENT fields 
% are used.
MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString.CONTENT = 'Hello World';
MyTree.MyString.ATTRIBUTE.Num = 2;
xml_write('test.xml', MyTree);
type('test.xml')
%%
% *Same operation using Apache Xerces XML engine*
Pref=[]; Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
xml_write('test.xml', MyTree, [], Pref);
type('test.xml')

%% Write XML files with COMMENTs
% Insertion of Comments is done with help of special COMMENT field.
% Note that MATLAB's xmlwrite is less readable due to lack of end-of-line 
% characters around comment section. 
MyTree=[];
MyTree.COMMENT = 'This is a comment';
MyTree.MyNumber = 13;
MyTree.MyString.CONTENT = 'Hello World';
xml_write('test.xml', MyTree);
type('test.xml')
%%
% *Same operation using Apache Xerces XML engine*
% gives the same result
Pref=[]; Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
xml_write('test.xml', MyTree, 'MyTree', Pref);
type('test.xml')

%%
% *Comments in XML top level (method #1)*
% This method uses cell array 
MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString = 'Hello World';
xml_write('test.xml', MyTree, {'MyTree', [], 'This is a global comment'});
type('test.xml')
%%
% *Same operation using Apache Xerces XML engine* 
% gives even nicer results.
Pref=[]; Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
xml_write('test.xml', MyTree, {'MyTree', [], 'This is a global comment'}, Pref);
type('test.xml')

%%
% *Comments in XML top level (method #2)*
% This method adds an extra top layer to the struct 'tree' and sets
% "Pref.RootOnly = false", which informs the function about the extra 
% layer. Notice that RootName is also saved as a part of
% the 'tree', and does not have to be passed in separately.
MyTree=[];
MyTree.COMMENT = 'This is a global comment';
MyTree.MyTest.MyNumber = 13;
MyTree.MyTest.MyString = 'Hello World';
Pref=[]; Pref.RootOnly = false;
xml_write('test.xml', MyTree, [], Pref);
type('test.xml')
%%
% *Same operation using Apache Xerces XML engine*
Pref=[]; Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
Pref.RootOnly  = false;
xml_write('test.xml', MyTree, [], Pref);
type('test.xml')

%% Write XML files with PROCESSING_INSTRUCTIONs 
% Insertion of Processing Instructions is done through use of special 
% PROCESSING_INSTRUCTION field, which stores the instruction string. The
% string has to be in 'target data' format separated by space.
MyTree=[];
MyTree.PROCESSING_INSTRUCTION = 'xml-stylesheet type="a" href="foo"';
MyTree.MyNumber = 13;
MyTree.MyString = 'Hello World';
xml_write('test.xml', MyTree);
type('test.xml')

%%
% *Same operation using Apache Xerces XML engine*
Pref=[]; Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
xml_write('test.xml', MyTree, 'MyTree', Pref);
type('test.xml')

%%
% *PROCESSING_INSTRUCTIONs in XML top level (method #1)*
% This method uses cell array 
MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString = 'Hello World';
xml_write('test.xml', MyTree, {'MyTree', 'xml-stylesheet type="a" href="foo"'});
type('test.xml')
%%
% *Same operation using Apache Xerces XML engine*
Pref=[]; Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
xml_write('test.xml', MyTree, {'MyTree', 'xml-stylesheet type="a" href="foo"'}, Pref);
type('test.xml')

%%
% *PROCESSING_INSTRUCTIONs in XML top level (method #2)*
% This method adds an extra top layer to the struct 'tree' and sets
% pref.RootOnly=false, which informs the function about the extra 
% layer. Notice that RootName is also saved as a part of
% the 'tree', and does not have to be passed in separately.
MyTree=[];
MyTree.PROCESSING_INSTRUCTION =  'xml-stylesheet type="a" href="foo"';
MyTree.MyTest.MyNumber = 13;
MyTree.MyTest.MyString = 'Hello World';
Pref=[]; Pref.RootOnly = false;
xml_write('test.xml', MyTree, [], Pref);
type('test.xml')
%%
% *Same operation using Apache Xerces XML engine*
Pref=[]; Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
Pref.RootOnly  = false;
xml_write('test.xml', MyTree, 'MyTree', Pref);
type('test.xml')

%% Write XML files with CDATA Sections 
% "In an XML document a CDATA (Character DATA) section is a section of 
%  element content that is marked for the parser to interpret as only 
%  character data, not markup." (from Wikipedia) 
% To insert CDATA Sections one use special CDATA_SECTION field,
%  which stores the instruction string. Note that MATLAB's xmlwrite created
%  wrong xml code for CDATA section
MyTree=[];
MyTree.CDATA_SECTION = '<A>txt</A>';
MyTree.MyNumber = 13;
MyTree.MyString = 'Hello World';
xml_write('test.xml', MyTree);
type('test.xml')
%%
% *Same operation using Apache Xerces XML engine produces correct results*
Pref=[]; Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
xml_write('test.xml', MyTree, 'MyTree', Pref);
type('test.xml')

%% Write XML files with special characters in TAG names
% The input to xml_write requires that all tags one wants in XML document 
% have to be encoded as field names of MATLAB's struct's. Matlab has a lot
% of restrictions on variable names. This section is about XML tags with
% names not allowed as MATLAB variables, or more specifically with
% characters allowed as xml tag names but not allowed as MATLAB variable
% names. Characters like that can be replaced by their hexadecimal
% representation just as it is done by genvarname function. Alternative way
% of writing the first example is:
MyTree=[];
MyTree.('MyNumber') = 13;               % same as MyTree.MyNumber = 13;
MyTree.MyString.CONTENT = 'Hello World';
MyTree.MyString.ATTRIBUTE.('Num') = 2;  % same as MyTree.MyString.ATTRIBUTE.Num = 2;
xml_write('test.xml', MyTree);
type('test.xml')

%%
% *This approach fails for some characters like dash '-', colon ':', and
% international characters.*
MyTree=[];
try
  MyTree.('My-Number') = 13;
  MyTree.MyString.CONTENT = 'Hello World';
  MyTree.MyString.ATTRIBUTE.('Num_') = 2;
catch
  err = lasterror;
  disp(err.message);
end

%%
% It can be overcome by replacing offending characters with their 
% hexadecimal representation. That can be done manually or with use of 
% genvarname function. Note that MATLAB 'type' function does not show
% correctly '' letter in xml file, but opening the file in editor shows 
% that it is correct.
MyTree=[];
MyTree.(genvarname('My-Number')) = 13;
MyTree.MyString.CONTENT = 'Hello World';
MyTree.MyString.ATTRIBUTE.Num_0xF6 = 2;
gen_object_display(MyTree);
xml_write('test.xml', MyTree);
type('test.xml')

%%
% *Also two of the characters '-' and ':' can be encoded by a special strings:
% '_DASH_' and '_COLON_' respectively*
MyTree=[];
MyTree.My_DASH_Number = 13;
MyTree.MyString.CONTENT = 'Hello World';
MyTree.MyString.ATTRIBUTE.Num0xF6 = 2;
xml_write('test.xml', MyTree);
type('test.xml')

%% Write XML files with Namespaces
% No extra special fields are needed to define XML namespaces, only colon 
% character written using '0x3A' or '_COLON_'. Below is an
% example of a namespace definition
MyTree=[];
MyTree.f_COLON_child.ATTRIBUTE.xmlns_COLON_f = 'http://www.foo.com';
MyTree.f_COLON_child.f_COLON_MyNumber = 13;
MyTree.f_COLON_child.f_COLON_MyString = 'Hello World';
xml_write('test.xml', MyTree, 'MyTree');
type('test.xml')
%%
% *Same operation using Apache Xerces XML engine*
Pref=[]; Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
xml_write('test.xml', MyTree, 'f_COLON_MyTree', Pref);
type('test.xml')

%% "Pref.KeepNS" flag in "xml_read"
% Thise option allow keeping  or exclusion of namespaces in tag names. 
% By default the namespace data is kept but it produces much longer field
% names in the output structure. Ignoring namespace will produce more
% readible output.
% Perform default read of file with namespace
tree = xml_read('test.xml');
gen_object_display(tree);

%%
% Now the same operation with KeepNS = false. 
Pref=[]; Pref.KeepNS = false; % do not read attributes
tree = xml_read('test.xml', Pref);
gen_object_display(tree);

%% Read XML files with special node types
% Display and read the file, then show the data structure. Note that 
% MATLAB 'type' function shows '' letter incorrectly as 'A' in xml file, 
% but opening the file in editor shows that it is correct.
fprintf('Test xml file:\n');
type('test_file.xml')
%%
% Read only the Root Element (default) 
[tree GlobalTextNodes] = xml_read('test_file.xml');
fprintf('Global Data (Root name, Global Processing Instructions and Global Comments):\n');
disp(GlobalTextNodes')
fprintf('\nStructure read from the file (uncludes COMMENT and CDATA sections):\n');
gen_object_display(tree);
%%
% Read the whole tree including global Comments and Processing Instructions
Pref=[]; Pref.RootOnly = false;
[tree GlobalTextNodes] = xml_read('test_file.xml', Pref);
fprintf('Global Data (Root name, Global Processing Instructions and Global Comments):\n');
disp(GlobalTextNodes')
fprintf('\nStructure read from the file (uncludes COMMENT and CDATA sections):\n');
gen_object_display(tree);

%% "Pref.ReadAttr" flag in "xml_read"
% Those option allow exclusion of attributes 
Pref=[]; Pref.ReadAttr = false; % do not read attributes
tree = xml_read('test_file.xml', Pref);
gen_object_display(tree);

%% "Pref.ReadSpec" flag in "xml_read"
% Those option allow exclusion of special nodes, like
% comments, processing instructions, CData sections, etc.
Pref=[]; Pref.ReadSpec = false; % do not read special node types
tree = xml_read('test_file.xml', Pref);
gen_object_display(tree);

%% "Pref.RootOnly" flag in "xml_read"
% As it was shown in previous examples RootOnly parameter can be used to
% capture global (top level) special nodes (like COMMENTs and
% PROCESSING_INSTRUCTIONs) which are ignored by default
Pref=[]; Pref.RootOnly = false; % do not read special node types
tree = xml_read('test_file.xml', Pref);
gen_object_display(tree);

%% "Pref.RootOnly" flag in "xml_write"
% Writing previously read tree with default "Pref.RootOnly = true" gives
% wrong output file
Pref=[]; Pref.RootOnly = true; % do not read special node types
xml_write('test.xml', tree, [], Pref);
fprintf('Test xml file:\n');
type('test.xml')
%%
% Writing the same tree with "Pref.RootOnly = false" gives correct output
Pref=[]; Pref.RootOnly = false; % do not read special node types
xml_write('test.xml', tree, [], Pref);
fprintf('Test xml file:\n');
type('test.xml')

%% "Pref.NumLevels" flag in "xml_read"
% This parameter allows user to skip parts of the tree in order to save
% time and memory. Usefull only in a rare case when a small portion of
% large XML file is needed.
%
% Create test tile
MyTree = [];
MyTree.Level1 = 1;
MyTree.Level1_.Level2 = 2;
MyTree.Level1_.Level2_.Level3 = 3;
MyTree.Level1_.Level2_.Level3_.Level4 = 4;
xml_write('test.xml', MyTree);
fprintf('Test xml file:\n');
type('test.xml')
%%
% *Use Default ("Pref.NumLevels = infinity") setting*
tree = xml_read('test.xml');
gen_object_display(tree);
%%
% *Limit the read to only 2 levels*
Pref=[]; Pref.NumLevels = 2; 
tree = xml_read('test.xml', Pref);
gen_object_display(tree);




%% Create DOM object based on a Struct using "xml_write"
% *Create Struct tree*
MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString = 'Hello World';
%%
% *Convert Struct to DOM object using xml_write*
DOM = xml_write([], MyTree); 
xmlwrite('test.xml', DOM);   % Save DOM object using MATLAB function 
type('test.xml')

%% Convert DOM object to Struct using "xml_read"
DOM = xmlread('test.xml');       % Read DOM object using MATLAB function
[tree treeName] = xml_read(DOM); % Convert DOM object to Struct
disp([treeName{1} ' ='])
gen_object_display(tree)

%% Write XML file based on a DOM using "xml_write_xerces"
xmlwrite_xerces('test.xml', DOM); % Save DOM object using Xerces library 
type('test.xml')

%% Write XML to string instead of a file
DOM = xml_write([], MyTree);
str = xmlwrite(DOM);
disp(str)

##### SOURCE END #####
-->
   </body>
</html>